#!/bin/sh

#===========================Configurations=================================#

defaultClearClipboardTime=15
defaultDeleteHTMLTime=30

## Number of characters to number randomly generate
defaultNumberOfChars=16

## What type of characters to randomly generate
## [:graph:] - All printable characters, except whitespace
## [:alnum:] - All letters and numbers
## [:alpha:] - Letters only
## [:lower:] - Capital letters only
## [:upper:] - Small letters only
## [:digit:] - Numbers only
## For more options, refer to the tr manual
defaultTypeOfChars="[:graph:]"

##Uncomment to override the script's home directory
#PPASSDB_HOME="./.${0##*/}" 

## Uncomment to ask the password everytime after previous encryption
#askPassEverytime="printf RELOADAGENT | gpg-connect-agent"

#==========================================================================#

usage() { echo "Usage: ${0##*/} <operation> [options] <filename>" 1>&2 ; }

noOperation() { usage ; echo "Type \"${0##*/} --help\" for more info" 1>&2 ; }

helpPage() {
	usage
	echo "
Operations:
help, --help	To shows this help message.
add, insert	For adding and encrypting text files.
open		For decrypting and opening an encrypted text file
list, ls	Lists all the added encrypted text files. If --catergory=
		is not specified, it will list all encrypted files
		from all groups.
location, pwd	Outputs the path to where all the encrypted files
		will be stored.

Options:
--notify	Pushes feedback messages to notifications (Only works on Linux)

Specific for add only:
--generate		Auto generates a random string and encrypts it.
--char-length=<NUMBER>	Specify the number of characters to randomly generate.
--char-type=<STRING>	Specify the type of characters to randomly generate.
	[:graph:] - All printable characters, except whitespace
	[:alnum:] - All letters and numbers
	[:alpha:] - Letters only
	[:lower:] - Capital letters only
	[:upper:] - Small letters only 
	[:digit:] - Numbers only
	For more options, refer to the tr manual
--recipient=<GPG ID>	Encrypts it with a existing user ID name made 
			with a key pair. Without this option, it will 
			use symetric encryption instead.
--multi-line		Encrypts a multi-line text instead of a
			single line.

Specific to both unlocking and adding:
-n, --no-clip	This option will not attempt to copy to clipboard.
-l, --clear		Clears the clipboard after a period of time.
--category=<name>	An identifier to group encrypted files. This is 
			optional and if this option is not called, it 
			will use the default folder.
-o, --show-secret	Shows the text. This will return a successful exit
			status even if the clipboard failed.
--html	Puts text to the generated html to 
		copy it from the web browser.
--forget	Forgets password after an operation was performed
--otp	For decryption, it converts the OTP URL to OTP code. For
		encryption, it verifies and tell information about the
		OTP URL to encrypt so to know whether the URL is valid
		for code generation.

Examples:
List all encrypted files:
${0##*/} list

Encrypt a text:
${0##*/} add --category=\"username\" \"website.pass\" 

Decrypts the password and put it into the system clipboard and clears for a 
period of time:
${0##*/} open --clear --category\"username\" \"website.pass\"

For full documentation, refer to the README.md file at
https://github.com/jamez2128/ppassdb/blob/master/README.md" 1>&2
}

checkDependecies() {
	{ command -v gpg2 > /dev/null && gnupg="gpg2" ; } ||
	{ command -v gpg > /dev/null && gnupg="gpg" ; } ||
	{ echo "gnupg is not installed" 1>&2 && exit 127 ; }
	if [ -n "$otpOption" ] && [ "$operation" = "decrypt" ] && ! command -v oathtool > /dev/null ; then
		echo "oathtool is not installed. It is required to generate OTP codes." 1>&2
		exit 1
	fi
}

searchHome() {
	dirName="${0##*/}"
	androidPath="/storage/emulated/0"
	# This line is possible thanks to this Reddit thread and especially this comment
	# https://www.reddit.com/r/bashonubuntuonwindows/comments/8dhhrr/comment/dxoxjzq/?utm_source=share&utm_medium=web2x&context=3
	[ "$oS" = "Windows" ] && APPDATA=$(cmd.exe /c "echo %APPDATA%" 2>/dev/null | sed -e 's/\r//g ; s/^C:\\//g ; s/\\/\//g')
	windowsPath="$windowsPrefix/$APPDATA"
	gnuLinuxPath="$HOME/.local/share"
	macPath="$HOME/Library/Application Support"
	xdgPath="$XDG_DATA_HOME"
	
	if [ -d "$androidPath/$dirName"  ] ; then
		[ ! -w "$androidPath" ] && echo "You don't have write permissions in Termux" 1>&2 && exit 1
		PPASSDB_HOME="$androidPath/$dirName"
	elif [ -d "$windowsPath/$dirName" ] ; then
		PPASSDB_HOME="$windowsPath/$dirName"
	elif [ -d "$macPath/$dirName" ] ; then PPASSDB_HOME="$macPath/$dirName"
	elif [ -d "$HOME/.$dirName" ] ; then PPASSDB_HOME="$HOME/.$dirName"
	elif [ -z "$XDG_DATA_HOME" ] && [ -d "$gnuLinuxPath/$dirName" ] ; then
		PPASSDB_HOME="$gnuLinuxPath/$dirName"
	elif [ -d "$xdgPath/$dirName" ] ; then PPASSDB_HOME="$xdgPath/$dirName"
	else defineHome
	fi
}

defineHome() {
	if [ -d "$androidPath" ] ; then PPASSDB_HOME="$androidPath/$dirName"
	elif [ -d "$windowsPath" ] ; then PPASSDB_HOME="$windowsPath/$dirName"
	elif [ -d "$macPath" ] ; then PPASSDB_HOME="$macPath/$dirName"
	elif [ -n "$XDG_DATA_HOME" ] ; then PPASSDB_HOME="$xdgPath/$dirName"
	elif [ -z "$XDG_DATA_HOME" ] && [ -d "$gnuLinuxPath" ] ; then
		PPASSDB_HOME="$gnuLinuxPath/$dirName"
	elif [ -z "$XDG_DATA_HOME" ] && [ ! -d "$gnuLinuxPath" ] ; then
		PPASSDB_HOME="$HOME/.$dirName"
	else PPASSDB_HOME="$(pwd)/.$dirName"
	fi
	mkdir -p "$PPASSDB_HOME"
}

changeDir() { cd "$PPASSDB_HOME" || { echo "${0##*/} home doesn't exist" 1>&2 ;  exit 2 ; } ; }

showPath() { changeDir && pwd && exit ; }

listdb() {
	changeDir
	{ [ -d "$(pwd)/$iD" ] && cd "$iD" ; } || { echo "$iD does not exist" 1>&2 ; exit 1 ; }
	printf "%s Home Directory\n%s\n" "${0##*/}" "$(pwd)"
	if [ "$(find ./ | wc -l)" -eq 1 ] ; then
		$message "There are no encrypted files added yet" 1>&2
		exit 1
	else
		{ command -v "tree" > /dev/null && tree -aR ; } || ls -AR
	fi
	
}

checkFileName() {
	# Thanks to pass for this line for detecting sneaky paths
	[ -z "$fileName" ] && echo "There is not input file" 1>&2 && exit 1
	[ -n "$iD" ] && echo "$iD" | grep -q "/\.\.$\|^\.\./\|/\.\./\|^\.\.$\|^/" &&
		echo "You've attempted to escape the home directory of the script." 1>&2 && exit 1
	[ -z "$iD" ] && iD="default"
	case $fileName in */*) echo "/'s are not accepted in file names." 1>&2 ; exit 1 ;; esac
	inputFile="$PPASSDB_HOME/$iD/$fileName"
	[ "$operation" = "encrypt" ] && [ ! -d "$iD" ] && mkdir -p "$PPASSDB_HOME/$iD"
	[ "$operation" = "decrypt" ] && [ ! -f "$inputFile" ] && { echo "The file does not exist" 1>&2 && exit 1 ; }
}

checkOptions() {
	{ [ -z "$recipient" ] && gpgEncryptOptions="-c --cipher-algo AES256" ; } || { gpgEncryptOptions="-e -r $recipient" ; }
	[ -z "$message" ] && message="echo"
	[ -z "$askPassEverytime" ] # To get rid of that error in shellcheck
}

checkOS() {
	msysCDrive="/c"
	wslCDrive="/mnt/c"
	if [ -d "$msysCDrive/Windows" ] || [ -d "$wslCDrive/Windows" ] ; then
		oS="Windows"
		{ [ -d "$msysCDrive/Windows" ] && windowsPrefix="$msysCDrive" ; } ||
		{ [ -d "$wslCDrive/Windows" ] && windowsPrefix="$wslCDrive" ; }
	else
		case "$(uname)" in
		*Linux) oS=$(uname -o) ;; 
		*) oS=$(uname) ;; 
		esac
	fi
}

#A workaround if the script failed to take care of the clipboard
#Good Alternative if you don't wanna use the -s option
makeHTML() {
	escapeText=$(printf "%s" "$textToCopy" | sed 's/[\\`]/\\&/g')
	htmlPath=$(mktemp -u).html
	fileNameOnly=${htmlPath##*/}
	if [ "$oS" = "Android" ] && [ -w "/storage/emulated/0" ] ; then
		htmlPath="/storage/emulated/0/$fileNameOnly}"
	elif [ "$oS" = "Android" ] ; then
		unset htmlPath
		echo "You don't have write permissions in Termux" 1>&2
		[ -z "$showSecretOption" ] && exit 1
	fi
	[ -n "$htmlPath" ] && 
	{
		cat << EOF
<html>
	<head>
	<title> $fileName | $iD | ${0##*/} </title>
	<script>
		function copyToClipboard() { 
			navigator.clipboard.writeText(\`$escapeText\`); 
		}
	</script>
</head>
<body>
	<p> Click <button onclick=copyToClipboard()> 
		Copy </button> to put decrypted text to Clipboard 
	</p>
</body>
</html>
EOF
	} > "$htmlPath"
	if [ -n "$htmlPath" ] ; then
		case "$oS" in
		"Windows") start "$htmlPath" ;;
		"GNU/Linux") command -v xdg-open > /dev/null && xdg-open "$htmlPath" > /dev/null 2>&1 ;;
		*) command -v open > /dev/null && open "$htmlPath" > /dev/null 2>&1 ;;
		esac
		echo "Your decrypted file is in file://$htmlPath" 1>&2
		[ "$oS" = "Android" ] && echo "It will be in the your Internal Storage" 1>&2
		echo "This file will be deleted in $deleteHTMLTime seconds" 1>&2
		sleep "$deleteHTMLTime" && [ -f "$htmlPath" ] && rm "$htmlPath" &
	fi
}

showSecret() { echo "$textToCopy" ; }

clearClipboard() {
	[ -n "$clipboard" ] && $message "Clearing the clipboard in $clearClipboardTime seconds" 1>&2
	sleep "$clearClipboardTime" && head /dev/null | $clipboard &
}

copyToClipboard() {
# Clipboards by OS'
	case $oS in
	"Windows") clipboard="clip.exe" ;;	
	"Android") command -v "termux-clipboard-set" > /dev/null && clipboard="termux-clipboard-set" ;;	
	*)
		{ [ -n "$WAYLAND_DISPLAY" ] && command -v wl-copy > /dev/null && clipboard="wl-copy" ; } ||
		{ [ -n "$DISPLAY" ] && command -v xclip > /dev/null && clipboard="xclip -selection clipboard" ; } ||
		{ command -v pbcopy > /dev/null && clipboard="pbcopy" ; }
		;;
	esac
	if [ -n "$clipboard" ] ; then
		printf "%s" "$textToCopy" | $clipboard && $message "Copied to Clipboard sucessfully" 1>&2
		[ -n "$clearClipOption" ] && clearClipboard
		
	else
		$message "Could not find any clipboards" 1>&2
		[ -z "$showSecretOption" ] && [ -z "$htmlOption" ] && exit 127
	fi
}

generateRandomText() { textToEncrypt=$(LC_CTYPE=C tr -dc "$typeOfChars" < /dev/urandom 2>/dev/null | head -c "$numberOfChars") ; }

oneLinerText() {
	stty -echo
	printf "Enter text to encrypt: " 1>&2 && read -r textToEncrypt ; echo
	printf "Enter the same text again: " 1>&2 && read -r confirmText ; echo	
	stty echo
	[ "$textToEncrypt" = "$confirmText" ] || { echo "Texts do not match" 1>&2 && exit 1 ; }
}

multiLinerText() {
	echo "Type or paste the text you want to encrypt. Press Enter and Ctrl+D when done:"  1>&2
	textToEncrypt=$(cat)
}

encryption() {
	checkDependecies
	checkFileName
	if [ -n "$generateOption" ]; then generateRandomText
	else
		{ [ -n "$multiLineOption" ] && multiLinerText ; } || oneLinerText
		if [ -n "$otpOption" ] ; then
			otp "$textToEncrypt" && echo "$fileName: OTP URL Validated" 1>&2 
		else
			echo "$fileName: OTP URL provided may be invalid" 1>&2 
		fi
	fi
	$askPassEverytime
	# shellcheck disable=SC2086
	printf "%s" "$textToEncrypt" | $gnupg $1 -o "$inputFile" || exit $?
	[ -n "$forgetImmediatelyOption" ] && printf "RELOADAGENT" | gpg-connect-agent
	textToCopy="$textToEncrypt"
	[ -z "$dontCopyOption" ] && [ -n "$generateOption" ] && [ -z "$htmlOption" ] && copyToClipboard
	[ -n "$htmlOption" ] && makeHTML
	[ -n "$showSecretOption" ] && showSecret
}

otp() {
	otpValidate=0
	case $operation in
	encrypt) failAction="return 1" ;;
	decrypt) failAction="exit 1" ;;
	esac

	case $1 in
	otpauth://*) otpType=${1#*//} otpType=${otpType%%/*} ;;
	*) $message "$fileName: Not a valid OTP auth URL" 1>&2 ; $failAction ;;
	esac

	case $1 in
	*counter=*) otpCounter=${1#*counter=} otpCounter=${otpCounter%%&*}  ;;
	*) 
		[ "$otpType" = "hotp" ] && 
		{
			echo "$fileName: Not a valid HOTP URL. No counter provided." 1>&2
	      		{ [ "$operation" = "decrypt" ] && exit 1 ; }
			otpValidate=1
       		} 
	;;
	esac

	case $1 in
	*secret=*) otpSecret=${1#*secret=} otpSecret=${otpSecret%%&*} ;;
	*)
		echo "$fileName Invalid URL. No secret is provided" 1>&2
	       	{ [ "$operation" = "decrypt" ] && exit 1 ; }
		otpValidate=1
	;;
	esac
	
	case $1 in 
	*algorithm=*) otpAlgorithm=${1#*algorithm=} otpAlgorithm=${otpAlgorithm%%&*} ;;
	*) otpAlgorithm="SHA1" ;;
	esac
	
	case $1 in 
	*digits=*) otpDigits=${1#*digits=} otpDigits=${otpDigits%%&*} ;;
	*) otpDigits=6 ;;
	esac
	
	case $1 in
	*period=*) otpPeriod=${1#*period=} otpPeriod=${otpPeriod%%&*} ;;
	*) otpPeriod=30  ;;
	esac

	case $otpType in
	totp) oathtoolArgs="--totp=$otpAlgorithm --time-step-size=$otpPeriod"  ;;
	hotp) $message "Only TOTP URL's are supported at this time." 1>&2 ; { [ "$operation" = "decrypt" ] && exit 1 ; } ;;
	esac
	[ "$operation" = "encrypt" ] && return $otpValidate

	# shellcheck disable=SC2086
	oathtool -b $oathtoolArgs --digits=$otpDigits "$otpSecret"
}

decryption() {
	checkDependecies
	checkFileName
	$askPassEverytime
	textToCopy=$($gnupg -d "$inputFile" 2>/dev/null) || exit $?
	[ -n "$otpOption" ] && textToCopy=$(otp "$textToCopy")
	[ -n "$forgetImmediatelyOption" ] && printf "RELOADAGENT" | gpg-connect-agent
	[ -z "$dontCopyOption" ] && [ -z "$htmlOption" ] && copyToClipboard
	[ -n "$htmlOption" ] && makeHTML
	[ -n "$showSecretOption" ] && showSecret
}

checkEnvVars() {
	if [ -n "$PPASSDB_HOME" ] ; then [ ! -d "$PPASSDB_HOME" ] && mkdir -p "$PPASSDB_HOME"
	else searchHome
	fi
	{ [ -n "$PPASSDB_CLEAR_TIME" ] && clearClipboardTime=$(printf "%i" "$PPASSDB_CLEAR_TIME") ; } || clearClipboardTime="$defaultClearClipboardTime"
	{ [ -n "$PPASSDB_DELETE_HTML_TIME" ] && deleteHTMLTime="$PPASSDB_DELETE_HTML_TIME" ; } || deleteHTMLTime="$defaultDeleteHTMLTime"
	{ [ -n "$PPASSDB_GENERATE_CHAR_TYPE" ] && typeOfChars="$PPASSDB_GENERATE_CHAR_TYPE" ; } || typeOfChars="$defaultTypeOfChars"
	[ -n "$PPASSDB_GENERATE_CHAR_LENGTH" ] && { numberOfChars=$(printf "%i" "$PPASSDB_GENERATE_CHAR_LENGTH") ; } || numberOfChars="$defaultNumberOfChars"
	[ -n "$PPASSDB_RECIPIENT" ] && recipient="$PPASSDB_RECIPIENT"
}

# Start of the script
[ $# -eq 0 ] && noOperation && exit 1
checkOS
checkEnvVars

case "$1" in
	--help|help) helpPage 2>&1 ; exit ;;
	add|insert) operation="encrypt";;
	list|ls) operation="list";;
	location|pwd) operation="path" ;;
	open) operation="decrypt" ;;
	*) echo "No operation specified" 1>&2 ; exit 1;;
esac
shift

while [ -n "$1" ] ; do
	case "$1" in
	--otp) otpOption=" " ; shift ;;
	-n|--no-clip) dontCopyOption=" " ; shift ;;
	-o|--show-secret) showSecretOption=" " ; shift ;;
	-l|--clear) clearClipOption=" " ; shift ;;
	--html) htmlOption=" " ; shift ;;
	-f|--forget) forgetImmediatelyOption=" " ; shift ;;
	-g|--generate) generateOption=" " ; shift ;;
	--char-length=*) numberOfChars=$(printf "%i" "${1#*=}") || exit $? ; shift ;;
	--char-type=*) typeOfChars=${1#*=} ;;
	--notify) command -v notify-send > /dev/null && message="notify-send" ; shift ;;
	--multi-line) multiLineOption=" " ; shift ;;
	--category=*) iD=${1#*=} ; shift ;;
	--recipient=*) recipient=${1#*=} ; shift ;;
	--) shift ; break  ;;
	*) { [ -z "$2" ] && fileName="$1" ; shift ; } || { echo "$1 is an unknown option" 1>&2 ; exit 1 ; } ;;
	esac
done
checkOptions

case "$operation" in
decrypt) decryption ;;
encrypt) encryption "$gpgEncryptOptions" ;;
list) listdb ;;
path) showPath ;;
esac
exit 0
