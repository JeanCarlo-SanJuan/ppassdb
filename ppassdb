#!/bin/sh

#===========================Configurations=================================#

defaultClearClipboardTime=15
defaultDeleteHTMLTime=30

## Number of characters to number randomly generate
defaultNumberOfChars=16

## What type of characters to randomly generate
## [:graph:] - All printable characters, except whitespace
## [:alnum:] - All letters and numbers
## [:alpha:] - Letters only
## [:lower:] - Capital letters only
## [:upper:] - Small letters only
## [:digit:] - Numbers only
## For more options, refer to the tr manual
defaultTypeOfChars="[:graph:]"

##Uncomment to override the script's home directory
#PPASSDB_HOME="./.${0##*/}" 

## Uncomment to ask the password everytime after previous encryption
#askPassEverytime=" "

#==========================================================================#

usage() { echo "Usage: ${0##*/} <operation> [options] <filename>" 1>&2 ; }

noOperation() { usage ; echo "Type \"${0##*/} --help\" for more info" 1>&2 ; }

helpPage() {
	usage
	echo "
Operations:
help, --help	To shows this help message.
add, insert	For adding and encrypting text files.
open		For decrypting and opening an encrypted text file
list, ls	Lists all the added encrypted text files. If a sub
		directory is not specified, it will list all 
		encrypted files from all subdirectories.
location, pwd	Outputs the path to where all the encrypted files
		will be stored.

Options:
--notify		Pushes feedback messages to notifications
			(Only works on Linux)

Specific for add only:
--image=\"</path/to/image.png>\"	Decodes QR Code and encrypts the text.
					If it is an OTP. It is highly recommended 
					to specify --otp to validate it when
					encrypting.
--generate		Auto generates a random string and encrypts it.
--char-length=<NUMBER>	Specify the number of characters to randomly generate.
--char-type=<STRING>	Specify the type of characters to randomly generate.
	[:graph:] - All printable characters, except whitespace
	[:alnum:] - All letters and numbers
	[:alpha:] - Letters only
	[:lower:] - Capital letters only
	[:upper:] - Small letters only 
	[:digit:] - Numbers only
	For more options, refer to the tr manual
--recipient=<GPG ID>	Encrypts it with a existing user ID name made 
			with a key pair. Without this option, it will 
			use symetric encryption instead.
--multi-line		Encrypts a multi-line text instead of a
			single line.

Specific to both open and add operations:
-n, --no-clip	This option will not attempt to copy to clipboard.
-l, --clear		Clears the clipboard after a period of time.
-o, --show-secret	Shows the text. This will return a successful exit
			status even if the clipboard failed.
--html			Puts text to the generated html to 
			copy it from the web browser.
--forget		Forgets password after an operation was performed
--otp		For decryption, it converts the OTP URL to OTP code. For
		encryption, it verifies and tell information about the
		OTP URL to encrypt so to know whether the URL is valid
		for code generation.
--qr-code	Encodes text to QR code. It is useful to scan
		OTP URL's to authenticator apps on phones. If you are 
		using it for OTP's, it is recommended to use
		the --otp option to validate it.

Examples:
List all encrypted files:
${0##*/} list

Encrypt a text:
${0##*/} add \"username/website.pass\" 

Decrypts the password and put it into the system clipboard and clears for a 
period of time:
${0##*/} open --clear  \"username/website.pass\"

For full documentation, refer to the README.md file at
https://github.com/jamez2128/ppassdb/blob/master/README.md" 1>&2
}

checkDependecies() {
	{ command -v gpg2 > /dev/null && gnupg="gpg2" ; } ||
	{ command -v gpg > /dev/null && gnupg="gpg" ; } ||
	{ echo "gnupg is not installed" 1>&2 && exit 127 ; }
	if [ -n "$otpOption" ] && [ "$operation" = "decrypt" ] && ! command -v oathtool > /dev/null ; then
		echo "oathtool is not installed. It is required to generate OTP codes." 1>&2
		exit 127
	fi
	if [ -n "$qrCodeOption" ] ; then
		case "$operation" in
		encrypt) ! command -v zbarimg > /dev/null && { echo "zbarimg is not installed. It is required to add OTP URL's from QR codes " 1>&2 ; exit 127  ; } ;;
		decrypt) ! command -v qrencode > /dev/null && { echo "qrencode is not installed. It is required to generate QR codes." 1>&2 ; exit 127 ; } ;;
		esac
	fi
}

searchHome() {
	dirName="${0##*/}"
	androidPath="/storage/emulated/0"
	# This line is possible thanks to this Reddit thread and especially this comment
	# https://www.reddit.com/r/bashonubuntuonwindows/comments/8dhhrr/comment/dxoxjzq/?utm_source=share&utm_medium=web2x&context=3
	[ "$oS" = "Windows" ] && APPDATA=$(cmd.exe /c "echo %APPDATA%" 2>/dev/null | sed -e 's/\r//g ; s/^C:\\//g ; s/\\/\//g')
	windowsPath="$windowsPrefix/$APPDATA"
	gnuLinuxPath="$HOME/.local/share"
	macPath="$HOME/Library/Application Support"
	xdgPath="$XDG_DATA_HOME"
	
	if [ -d "$androidPath/$dirName"  ] ; then
		[ ! -w "$androidPath" ] && echo "You don't have write permissions in Termux" 1>&2 && exit 1
		PPASSDB_HOME="$androidPath/$dirName"
	elif [ -d "$windowsPath/$dirName" ] ; then
		PPASSDB_HOME="$windowsPath/$dirName"
	elif [ -d "$macPath/$dirName" ] ; then PPASSDB_HOME="$macPath/$dirName"
	elif [ -d "$HOME/.$dirName" ] ; then PPASSDB_HOME="$HOME/.$dirName"
	elif [ -z "$XDG_DATA_HOME" ] && [ -d "$gnuLinuxPath/$dirName" ] ; then
		PPASSDB_HOME="$gnuLinuxPath/$dirName"
	elif [ -d "$xdgPath/$dirName" ] ; then PPASSDB_HOME="$xdgPath/$dirName"
	else defineHome
	fi
}

defineHome() {
	if [ -d "$androidPath" ] ; then PPASSDB_HOME="$androidPath/$dirName"
	elif [ -d "$windowsPath" ] ; then PPASSDB_HOME="$windowsPath/$dirName"
	elif [ -d "$macPath" ] ; then PPASSDB_HOME="$macPath/$dirName"
	elif [ -n "$XDG_DATA_HOME" ] ; then PPASSDB_HOME="$xdgPath/$dirName"
	elif [ -z "$XDG_DATA_HOME" ] && [ -d "$gnuLinuxPath" ] ; then
		PPASSDB_HOME="$gnuLinuxPath/$dirName"
	elif [ -z "$XDG_DATA_HOME" ] && [ ! -d "$gnuLinuxPath" ] ; then
		PPASSDB_HOME="$HOME/.$dirName"
	else PPASSDB_HOME="$(pwd)/.$dirName"
	fi
	mkdir -p "$PPASSDB_HOME"
}

changeDir() { cd "$PPASSDB_HOME" || { echo "${0##*/} home doesn't exist" 1>&2 ;  exit 2 ; } ; }

showPath() { changeDir && pwd && exit ; }

listdb() {
	changeDir
	if [ -e "$(pwd)/$inputFile" ] ; then
		{ [ -d "$(pwd)/$inputFile" ] && cd "$inputFile" ; } || { [ -f "$(pwd)/$inputFile" ] && echo "$inputFile is a file" 1>&2 && exit 1 ; }
	else
 		echo "$inputFile does not exist" 1>&2
		exit 1
	fi
	printf "%s Home Directory\n%s\n" "${0##*/}" "$(pwd)"
	if [ "$(find ./ | wc -l)" -eq 1 ] ; then
		$message "There are no encrypted files added yet" 1>&2
		exit 1
	else
		{ command -v "tree" > /dev/null && tree -aR ; } || ls -AR
	fi
	
}

checkFileName() {
	[ -z "$inputFile" ] && echo "There is not input file" 1>&2 && exit 1
	# Thanks to pass for this line for detecting sneaky paths
	[ -n "$inputFile" ] && echo "$inputFile" | grep -q "/\.\.$\|^\.\./\|/\.\./\|^\.\.$\|^/" &&
		echo "You've attempted to escape the home directory of the script." 1>&2 && exit 1
	inputFile="$PPASSDB_HOME/$inputFile"
	[ "$operation" = "encrypt" ] && [ ! -d "${inputFile%/*}" ] && mkdir -p "${inputFile%/*}"
	[ "$operation" = "decrypt" ] && [ ! -f "$inputFile" ] && { echo "The file does not exist" 1>&2 && exit 1 ; }
}

checkOptions() {
	{ [ -z "$recipient" ] && gpgEncryptOptions="-c --cipher-algo AES256" ; } || { gpgEncryptOptions="-e -r $recipient" ; }
	[ -z "$message" ] && message="echo"
}

checkOS() {
	msysCDrive="/c"
	wslCDrive="/mnt/c"
	if [ -d "$msysCDrive/Windows" ] || [ -d "$wslCDrive/Windows" ] ; then
		oS="Windows"
		{ [ -d "$msysCDrive/Windows" ] && windowsPrefix="$msysCDrive" ; } ||
		{ [ -d "$wslCDrive/Windows" ] && windowsPrefix="$wslCDrive" ; }
	else
		case "$(uname)" in
		*Linux) oS=$(uname -o) ;; 
		*) oS=$(uname) ;; 
		esac
	fi
}

#A workaround if the script failed to take care of the clipboard
#Good Alternative if you don't wanna use the -s option
makeHTML() {
	escapeText=$(printf "%s" "$textToCopy" | sed 's/[\\`]/\\&/g')
	htmlPath=$(mktemp -u).html
	fileNameOnly=${htmlPath##*/}
	if [ "$oS" = "Android" ] && [ -w "/storage/emulated/0" ] ; then
		htmlPath="/storage/emulated/0/$fileNameOnly}"
	elif [ "$oS" = "Android" ] ; then
		unset htmlPath
		echo "You don't have write permissions in Termux" 1>&2
		[ -z "$showSecretOption" ] && exit 1
	fi
	[ -n "$htmlPath" ] && 
	{
		cat << EOF
<html>
	<head>
	<title> ${inputFile#"$PPASSDB_HOME/"} | ${0##*/} </title>
	<script>
		function copyToClipboard() { 
			navigator.clipboard.writeText(\`$escapeText\`); 
		}
	</script>
</head>
<body>
	<p> Click <button onclick=copyToClipboard()> 
		Copy </button> to put decrypted text to Clipboard 
	</p>
</body>
</html>
EOF
	} > "$htmlPath"
	if [ -n "$htmlPath" ] ; then
		case "$oS" in
		"Windows") start "$htmlPath" ;;
		"GNU/Linux") command -v xdg-open > /dev/null && xdg-open "$htmlPath" > /dev/null 2>&1 ;;
		*) command -v open > /dev/null && open "$htmlPath" > /dev/null 2>&1 ;;
		esac
		echo "Your decrypted file is in file://$htmlPath" 1>&2
		[ "$oS" = "Android" ] && echo "It will be in the your Internal Storage" 1>&2
		echo "This file will be deleted in $deleteHTMLTime seconds" 1>&2
		sleep "$deleteHTMLTime" && [ -f "$htmlPath" ] && rm "$htmlPath" &
	fi
}

showSecret() { echo "$textToCopy" ; }

clearClipboard() {
	[ -n "$clipboard" ] && $message "Clearing the clipboard in $clearClipboardTime seconds" 1>&2
	sleep "$clearClipboardTime" && head /dev/null | $clipboard &
}

copyToClipboard() {
# Clipboards by OS'
	case $oS in
	"Windows") clipboard="clip.exe" ;;	
	"Android") command -v "termux-clipboard-set" > /dev/null && clipboard="termux-clipboard-set" ;;	
	*)
		{ [ -n "$WAYLAND_DISPLAY" ] && command -v wl-copy > /dev/null && clipboard="wl-copy" ; } ||
		{ [ -n "$DISPLAY" ] && command -v xclip > /dev/null && clipboard="xclip -selection clipboard" ; } ||
		{ command -v pbcopy > /dev/null && clipboard="pbcopy" ; }
		;;
	esac
	if [ -n "$clipboard" ] ; then
		printf "%s" "$textToCopy" | $clipboard && $message "Copied to Clipboard sucessfully" 1>&2
		[ -n "$clearClipOption" ] && clearClipboard
		
	else
		$message "Could not find any clipboards" 1>&2
		[ -z "$showSecretOption" ] && [ -z "$htmlOption" ] && exit 127
	fi
}

generateRandomText() { textToEncrypt=$(LC_CTYPE=C tr -dc "$typeOfChars" < /dev/urandom 2>/dev/null | head -c "$numberOfChars") ; }

oneLinerText() {
	stty -echo
	printf "Enter text to encrypt: " 1>&2 && read -r textToEncrypt ; echo
	printf "Enter the same text again: " 1>&2 && read -r confirmText ; echo	
	stty echo
	[ "$textToEncrypt" = "$confirmText" ] || { echo "Texts do not match" 1>&2 && exit 1 ; }
}

multiLinerText() {
	echo "Type or paste the text you want to encrypt. Press Enter and Ctrl+D when done:"  1>&2
	textToEncrypt=$(cat)
}

encryption() {
	checkDependecies
	checkFileName
	if [ -n "$generateOption" ] ; then generateRandomText
	elif [ -n "$imageSource" ] ; then
		[ -f "$imageSource" ] && { textToEncrypt=$(zbarimg -q --raw "$imageSource") || exit $? ; }
	else
		{ [ -n "$multiLineOption" ] && multiLinerText ; } || oneLinerText
	fi
	# shellcheck disable=SC2086
	printf "%s" "$textToEncrypt" | $gnupg $1 -o "$inputFile" || exit $?
	textToCopy="$textToEncrypt"
	if [ -n "$otpOption" ] ; then
		validateOtp "$textToCopy" && echo "${inputFile#"$PPASSDB_HOME/"}: OTP URL Validated" 1>&2 || echo "${inputFile#"$PPASSDB_HOME/"}: OTP URL provided may be invalid" 1>&2 
	fi
	[ -z "$dontCopyOption" ] && { [ -n "$generateOption" ] || [ -n "$imageSource" ] ; } && [ -z "$htmlOption" ] && copyToClipboard
	[ -n "$htmlOption" ] && makeHTML
	[ -n "$showSecretOption" ] && showSecret
	[ -n "$qrCodeOption" ] && generateQrCode "$textToCopy"
}

generateQrCode() {
	qrencode -t UTF8 "$1"
}

validateOtp() {
	otpValidate=0

	case $1 in
	otpauth://*) otpType=${1#*//} otpType=${otpType%%/*} ;;
	*) $message "${inputFile#"$PPASSDB_HOME/"}: Not a valid OTP auth URL" 1>&2 ; return 1 ;;
	esac

	case $1 in
	*counter=*) otpCounter=${1#*counter=} otpCounter=${otpCounter%%&*}  ;;
	*) [ "$otpType" = "hotp" ] && echo "${inputFile#"$PPASSDB_HOME/"}: Not a valid HOTP URL. No counter provided." 1>&2 && otpValidate=1
	;;
	esac

	case $1 in
	*secret=*) otpSecret=${1#*secret=} otpSecret=${otpSecret%%&*} ;;
	*)
		echo "${inputFile#"$PPASSDB_HOME/"} Invalid URL. No secret is provided" 1>&2
		otpValidate=1
	;;
	esac
	
	case $1 in 
	*algorithm=*) otpAlgorithm=${1#*algorithm=} otpAlgorithm=${otpAlgorithm%%&*} ;;
	*) otpAlgorithm="SHA1" ;;
	esac
	
	case $1 in 
	*digits=*) otpDigits=${1#*digits=} otpDigits=${otpDigits%%&*} ;;
	*) otpDigits=6 ;;
	esac
	
	case $1 in
	*period=*) otpPeriod=${1#*period=} otpPeriod=${otpPeriod%%&*} ;;
	*) otpPeriod=30  ;;
	esac

	case $otpType in
	totp) oathtoolArgs="--totp=$otpAlgorithm --time-step-size=$otpPeriod"  ;;
	hotp) $message "Only TOTP URL's are supported at this time." 1>&2 ;;
	esac
	return $otpValidate
}

otpCode() {
	# shellcheck disable=SC2086
	validateOtp "$1" && oathtool -b $oathtoolArgs --digits=$otpDigits "$otpSecret" || exit $?
}

decryption() {
	checkDependecies
	checkFileName
	[ -n "$askPassEverytime" ] && printf "RELOADAGENT" | gpg-connect-agent
	textToCopy=$($gnupg -d "$inputFile") || exit $?
	if [ -n "$otpOption" ] && [ -z "$qrCodeOption" ]  ; then
 		textToCopy=$(otpCode "$textToCopy") || exit $?
	elif [ -n "$qrCodeOption" ] && [ -n "$otpOption" ] ; then
		validateOtp "$textToCopy" && echo "${inputFile#"$PPASSDB_HOME/"}: OTP URL validated" 1>&2 || echo "${inputFile#"$PPASSDB_HOME/"}: This QR code may not work on autheticator apps" 1>&2
	fi
	[ -n "$forgetImmediatelyOption" ] && printf "RELOADAGENT" | gpg-connect-agent > /dev/null
	[ -z "$dontCopyOption" ] && [ -z "$htmlOption" ] && copyToClipboard
	[ -n "$htmlOption" ] && makeHTML
	[ -n "$showSecretOption" ] && showSecret
	[ -n "$qrCodeOption" ] && generateQrCode "$textToCopy"

}

checkEnvVars() {
	if [ -n "$PPASSDB_HOME" ] ; then [ ! -d "$PPASSDB_HOME" ] && mkdir -p "$PPASSDB_HOME"
	else searchHome
	fi
	{ [ -n "$PPASSDB_CLEAR_TIME" ] && clearClipboardTime=$(printf "%i" "$PPASSDB_CLEAR_TIME") ; } || clearClipboardTime="$defaultClearClipboardTime"
	{ [ -n "$PPASSDB_DELETE_HTML_TIME" ] && deleteHTMLTime="$PPASSDB_DELETE_HTML_TIME" ; } || deleteHTMLTime="$defaultDeleteHTMLTime"
	{ [ -n "$PPASSDB_GENERATE_CHAR_TYPE" ] && typeOfChars="$PPASSDB_GENERATE_CHAR_TYPE" ; } || typeOfChars="$defaultTypeOfChars"
	[ -n "$PPASSDB_GENERATE_CHAR_LENGTH" ] && { numberOfChars=$(printf "%i" "$PPASSDB_GENERATE_CHAR_LENGTH") ; } || numberOfChars="$defaultNumberOfChars"
	[ -n "$PPASSDB_RECIPIENT" ] && recipient="$PPASSDB_RECIPIENT"
}

# Start of the script
[ $# -eq 0 ] && noOperation && exit 1
checkOS
checkEnvVars

case "$1" in
	--help|help) helpPage 2>&1 ; exit ;;
	add|insert) operation="encrypt";;
	list|ls) operation="list";;
	location|pwd) operation="path" ;;
	open) operation="decrypt" ;;
	*) echo "No operation specified" 1>&2 ; noOperation ; exit 1;;
esac
shift

while [ -n "$1" ] ; do
	case "$1" in
	--image=*) imageSource=${1#*=}  ; shift ;;
	--qr-code) qrCodeOption=" " ; shift ;;
	--otp) otpOption=" " ; shift ;;
	-n|--no-clip) dontCopyOption=" " ; shift ;;
	-o|--show-secret) showSecretOption=" " ; shift ;;
	-l|--clear) clearClipOption=" " ; shift ;;
	--html) htmlOption=" " ; shift ;;
	-f|--forget) forgetImmediatelyOption=" " ; shift ;;
	-g|--generate) generateOption=" " ; shift ;;
	--char-length=*) numberOfChars=$(printf "%i" "${1#*=}") || exit $? ; shift ;;
	--char-type=*) typeOfChars=${1#*=} ; shift ;;
	--notify) command -v notify-send > /dev/null && message="notify-send" ; shift ;;
	--multi-line) multiLineOption=" " ; shift ;;
	--recipient=*) recipient=${1#*=} ; shift ;;
	--) shift ; break  ;;
	*) { [ -z "$2" ] && inputFile="$1" ; shift ; } || { echo "$1 is an unknown option" 1>&2 ; exit 1 ; } ;;
	esac
done
[ -z "$inputFile" ] && inputFile="$1"
checkOptions

case "$operation" in
decrypt) decryption ;;
encrypt) encryption "$gpgEncryptOptions" ;;
list) listdb ;;
path) showPath ;;
esac
exit 0
